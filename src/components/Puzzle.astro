
<div class="puzzle-container">
  <!--<div class="controls-row">-->
    <div class="controls-group">
      <select id="difficultySelect" class="control-btn">
        <option value="easy">Easy (Ages 3-5)</option>
        <option value="medium">Medium (Ages 5-6)</option>
        <option value="hard">Hard (Ages 7-8)</option>
      </select>
      <button id="newPuzzleBtn" class="control-btn">New Puzzle</button>
      <button id="solutionBtn" class="control-btn">Solution</button>
      <button id="clearBtn" class="control-btn">Clear</button>
      <button class="control-btn" id="themeToggle">ðŸŒ“ Theme</button>
    </div>
  <!--</div>-->

  <div class="stats-container">
    <div class="stats-button">
      <span>Clicks: <span id="clickCount">0</span></span>
    </div>
    <div class="stats-button">
      <span>Found: <span id="foundCount">0</span>/<span id="totalWords"></span></span>
    </div>
  </div>

  <div class="word-list" id="wordList"></div>
  <div id="grid" class="grid"></div>
</div>

<!-- Using a module so we can import the JSON -->
<script type="module">
  // Import the word data from your JSON file
  import crosswordData from '../../public/mocks/cross.json';

  // Use the imported JSON data for word sets.
  const wordSets = crosswordData;
  //state.wordColorIndex = 0;
  let state = {
    difficulty: "easy",
    grid: [],
    size: 8,
    selectedCells: [],
    foundWords: [],
    isDragging: false,
    showSolution: false,
    solutions: [],
    clickCount: 0,
    matchedCells: [],
    directionColors: {
      horizontal: "hsla(120, 70%, 70%, 0.5)",
      vertical: "hsla(200, 70%, 70%, 0.5)",
      diagonal: "hsla(300, 70%, 70%, 0.5)"
    }
  };

  function generateRandomLetter() {
    return String.fromCharCode(65 + Math.floor(Math.random() * 26));
  }

  function getWordDirection(cells) {
    const [[r1, c1], [r2, c2]] = [cells[0], cells[cells.length - 1]];
    return r1 === r2 ? "horizontal" : c1 === c2 ? "vertical" : "diagonal";
  }

  function canPlaceWord(grid, word, row, col, dRow, dCol) {
    if (row + dRow * (word.length - 1) >= state.size || row + dRow * (word.length - 1) < 0) return false;
    if (col + dCol * (word.length - 1) >= state.size || col + dCol * (word.length - 1) < 0) return false;

    for (let i = 0; i < word.length; i++) {
      const currentCell = grid[row + dRow * i][col + dCol * i];
      if (currentCell && currentCell !== word[i]) return false;
    }
    return true;
  }

  function placeWord(grid, word) {
    const directions = [
      [0, 1],
      [1, 0],
      [1, 1]
    ];
    for (let attempt = 0; attempt < 100; attempt++) {
      const [dRow, dCol] = directions[Math.floor(Math.random() * directions.length)];
      const row = Math.floor(Math.random() * state.size);
      const col = Math.floor(Math.random() * state.size);

      if (canPlaceWord(grid, word, row, col, dRow, dCol)) {
        const wordCells = [];
        for (let i = 0; i < word.length; i++) {
          const r = row + dRow * i;
          const c = col + dCol * i;
          grid[r][c] = word[i];
          wordCells.push([r, c]);
        }
        return { placed: true, cells: wordCells, direction: getWordDirection(wordCells) };
      }
    }
    return { placed: false, cells: [], direction: null };
  }

  function generatePuzzle() {
    const newGrid = Array(state.size)
      .fill()
      .map(() => Array(state.size).fill(""));
    const words = wordSets[state.difficulty];
    state.solutions = [];

    words.forEach((word) => {
      const result = placeWord(newGrid, word);
      if (result.placed) {
        state.solutions.push({ word, cells: result.cells, direction: result.direction });
      }
    });

    for (let i = 0; i < state.size; i++) {
      for (let j = 0; j < state.size; j++) {
        newGrid[i][j] = newGrid[i][j] || generateRandomLetter();
      }
    }

    state.grid = newGrid;
    state.foundWords = [];
    state.showSolution = false;
    state.selectedCells = [];
    state.clickCount = 0;
    state.matchedCells = [];
    updateDOM();
  }

  function isValidNextCell(current, next) {
    const [r1, c1] = current;
    const [r2, c2] = next;
    return Math.abs(r1 - r2) <= 1 && Math.abs(c1 - c2) <= 1;
  }

  function checkForWord(selection) {
    if (selection.length < 3) return false;

    const word = selection.map(([r, c]) => state.grid[r][c]).join("");
    const reverseWord = word.split("").reverse().join("");

    if (wordSets[state.difficulty].includes(word) && !state.foundWords.includes(word)) {
      state.foundWords.push(word);
      state.matchedCells.push(...selection);
      return true;
    } else if (wordSets[state.difficulty].includes(reverseWord) && !state.foundWords.includes(reverseWord)) {
      state.foundWords.push(reverseWord);
      state.matchedCells.push(...selection);
      return true;
    }
    return false;
  }

  function getCellCoordinates(element) {
    if (!element?.dataset?.coords) return null;
    return element.dataset.coords.split("-").map(Number);
  }

  function updateDOM() {
    const gridElement = document.getElementById("grid");
    gridElement.innerHTML = "";
    gridElement.style.gridTemplateColumns = `repeat(${state.size}, 1fr)`;

    state.grid.forEach((row, i) =>
      row.forEach((cell, j) => {
        const cellElement = document.createElement("div");
        cellElement.className = "cell";
        cellElement.textContent = cell;
        cellElement.dataset.coords = `${i}-${j}`;

        const isSelected = state.selectedCells.some(([r, c]) => r === i && c === j);
        const isMatched = state.matchedCells.some(([r, c]) => r === i && c === j);
        const isSolution =
          state.showSolution && state.solutions.some((s) => s.cells.some(([r, c]) => r === i && c === j));

        if (isSelected) cellElement.classList.add("selected");
        if (isMatched) cellElement.classList.add("match");
        if (isSolution) {
          const direction = state.solutions.find((s) =>
            s.cells.some(([r, c]) => r === i && c === j)
          )?.direction;
          cellElement.style.backgroundColor = state.directionColors[direction];
        }

        gridElement.appendChild(cellElement);
      })
    );

    document.getElementById("clickCount").textContent = state.clickCount;
    document.getElementById("foundCount").textContent = state.foundWords.length;
    document.getElementById("totalWords").textContent = wordSets[state.difficulty].length;
    document.getElementById("solutionBtn").textContent = state.showSolution ? "Hide Solution" : "Show Solution";

    const wordList = document.getElementById("wordList");
    wordList.innerHTML = wordSets[state.difficulty]
      .map(
        (word) => `<span class="word ${state.foundWords.includes(word) ? "found" : ""}">${word}</span>`
      )
      .join("");
  }

  function handleDragStart(e) {
    const coords = getCellCoordinates(e.target);
    if (!coords) return;

    state.isDragging = true;
    state.selectedCells = [coords];
    state.clickCount++;
    updateDOM();
  }

  function handleDragMove(e) {
    if (!state.isDragging) return;

    const element = document.elementFromPoint(
      e.type.includes("touch") ? e.touches[0].clientX : e.clientX,
      e.type.includes("touch") ? e.touches[0].clientY : e.clientY
    );

    const coords = getCellCoordinates(element);
    if (!coords) return;

    const lastCell = state.selectedCells[state.selectedCells.length - 1];
    if (!lastCell || !isValidNextCell(lastCell, coords)) return;

    if (!state.selectedCells.some(([r, c]) => r === coords[0] && c === coords[1])) {
      state.selectedCells.push(coords);
      updateDOM();
    }
  }

  function handleDragEnd() {
    if (!state.isDragging) return;

    if (checkForWord(state.selectedCells)) {
      updateDOM();
    }

    state.isDragging = false;
    state.selectedCells = [];
    updateDOM();
  }

  document.addEventListener("DOMContentLoaded", () => {
    const gridElement = document.getElementById("grid");

    // Mouse events
    gridElement.addEventListener("mousedown", handleDragStart);
    gridElement.addEventListener("mousemove", handleDragMove);
    document.addEventListener("mouseup", handleDragEnd);

    // Touch events
    gridElement.addEventListener("touchstart", (e) => {
      e.preventDefault();
      handleDragStart(e);
    });

    gridElement.addEventListener("touchmove", (e) => {
      e.preventDefault();
      handleDragMove(e);
    });

    gridElement.addEventListener("touchend", (e) => {
      e.preventDefault();
      handleDragEnd();
    });

    // Controls
    document.getElementById("difficultySelect").addEventListener("change", (e) => {
      state.difficulty = e.target.value;
      generatePuzzle();
    });

    document.getElementById("newPuzzleBtn").addEventListener("click", generatePuzzle);

    document.getElementById("solutionBtn").addEventListener("click", () => {
      state.showSolution = !state.showSolution;
      updateDOM();
    });

    document.getElementById("clearBtn").addEventListener("click", () => {
      state.selectedCells = [];
      state.isDragging = false;
      updateDOM();
    });

    document.getElementById("themeToggle").addEventListener("click", () => {
      document.body.dataset.theme = document.body.dataset.theme === "dark" ? "" : "dark";
    });

    generatePuzzle();
  });
</script>
