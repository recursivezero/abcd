<div class="puzzle-container">
  <div class="controls-group">
    <!--<details>
      <summary>Word List</summary>-->
    <button id="newPuzzleBtn" class="control-btn">New Puzzle</button>
    <button id="resetBtn" class="control-btn">Shuffle</button>
    <button id="clearBtn" class="control-btn">Clear</button>
    <button class="control-btn" id="themeToggle"> Theme</button>
  <!--</details>-->
    <select id="difficultySelect" class="control-btn">
      <option value="easy">Easy (Ages 3-5)</option>
      <option value="medium">Medium (Ages 5-6)</option>
      <option value="hard">Hard (Ages 7-8)</option>
    </select>
    <button id="solutionBtn" class="control-btn">Hint</button>
  </div>


  <div class="stats-container">
    <div class="stats-button">
      <span>Clicks: <span id="clickCount">0</span></span>
    </div>
    <div class="stats-button">
      <span>Found: <span id="foundCount">0</span>/<span id="totalWords"></span></span>
    </div>
  </div>

  <details>
    <summary>Word List</summary>
  <div class="word-list" id="wordList"></div>
</details>
  <div id="grid" class="grid"></div>
</div>


<!-- Using a module so we can import the JSON -->
<script type="module">
  // Import the word data from your JSON file
  import crosswordData from '../../public/mocks/cross.json';

  // Use the imported JSON data for word sets.
  const wordSets = crosswordData;
  let currentWordSetIndex = 0;
  
  const colorClasses = [
    'word-color-1',
    'word-color-2',
    'word-color-3',
    'word-color-4',
    'word-color-5',
    'word-color-6',
    'word-color-7',
    'word-color-8'
  ];
  
  let state = {
    difficulty: "easy",
    grid: [],
    size: 8,
    selectedCells: [],
    foundWords: [],
    isDragging: false,
    showSolution: false,
    solutions: [],
    clickCount: 0,
    matchedCells: new Map(), // Changed to Map to store word-cells associations
    currentWordSet: wordSets[0],
    directionColors: {
      horizontal: "hsla(120, 70%, 70%, 0.5)",
      vertical: "hsla(200, 70%, 70%, 0.5)",
      diagonal: "hsla(300, 70%, 70%, 0.5)"
    },
    wordColors: new Map() // Track colors assigned to words
  };

  function generateRandomLetter() {
    return String.fromCharCode(65 + Math.floor(Math.random() * 26));
  }

  function getWordDirection(cells) {
    const [[r1, c1], [r2, c2]] = [cells[0], cells[cells.length - 1]];
    return r1 === r2 ? "horizontal" : c1 === c2 ? "vertical" : "diagonal";
  }

  function canPlaceWord(grid, word, row, col, dRow, dCol) {
    if (row + dRow * (word.length - 1) >= state.size || row + dRow * (word.length - 1) < 0) return false;
    if (col + dCol * (word.length - 1) >= state.size || col + dCol * (word.length - 1) < 0) return false;

    for (let i = 0; i < word.length; i++) {
      const currentCell = grid[row + dRow * i][col + dCol * i];
      if (currentCell && currentCell !== word[i]) return false;
    }
    return true;
  }

  function placeWord(grid, word) {
    const directions = [
      [0, 1],
      [1, 0],
      [1, 1]
    ];
    for (let attempt = 0; attempt < 100; attempt++) {
      const [dRow, dCol] = directions[Math.floor(Math.random() * directions.length)];
      const row = Math.floor(Math.random() * state.size);
      const col = Math.floor(Math.random() * state.size);

      if (canPlaceWord(grid, word, row, col, dRow, dCol)) {
        const wordCells = [];
        for (let i = 0; i < word.length; i++) {
          const r = row + dRow * i;
          const c = col + dCol * i;
          grid[r][c] = word[i];
          wordCells.push([r, c]);
        }
        return { placed: true, cells: wordCells, direction: getWordDirection(wordCells) };
      }
    }
    return { placed: false, cells: [], direction: null };
  }

  function resetPuzzle() {
    generatePuzzleWithCurrentWordSet();
  }
  
  function generatePuzzleWithCurrentWordSet() {
    const newGrid = Array(state.size)
      .fill()
      .map(() => Array(state.size).fill(""));
    const words = state.currentWordSet[state.difficulty];
    state.solutions = [];
    state.wordColors.clear();
    state.matchedCells.clear();

    words.forEach((word) => {
      const result = placeWord(newGrid, word);
      if (result.placed) {
        state.solutions.push({ word, cells: result.cells, direction: result.direction });
      }
    });

    for (let i = 0; i < state.size; i++) {
      for (let j = 0; j < state.size; j++) {
        newGrid[i][j] = newGrid[i][j] || generateRandomLetter();
      }
    }

    state.grid = newGrid;
    state.foundWords = [];
    state.showSolution = false;
    state.selectedCells = [];
    state.clickCount = 0;
    updateDOM();
  }
  
  function generateNewPuzzle() {
    currentWordSetIndex = (currentWordSetIndex + 1) % wordSets.length;
    state.currentWordSet = wordSets[currentWordSetIndex];
    generatePuzzleWithCurrentWordSet();
  }

  function isValidNextCell(current, next) {
    const [r1, c1] = current;
    const [r2, c2] = next;
    return Math.abs(r1 - r2) <= 1 && Math.abs(c1 - c2) <= 1;
  }

  function checkForWord(selection) {
    if (selection.length < 3) return false;

    const word = selection.map(([r, c]) => state.grid[r][c]).join("");
    const reverseWord = word.split("").reverse().join("");
    const currentWords = state.currentWordSet[state.difficulty];

    let foundWord = null;
    if (currentWords.includes(word) && !state.foundWords.includes(word)) {
      foundWord = word;
    } else if (currentWords.includes(reverseWord) && !state.foundWords.includes(reverseWord)) {
      foundWord = reverseWord;
    }

    if (foundWord) {
      state.foundWords.push(foundWord);
      // Assign a color to the word
      if (!state.wordColors.has(foundWord)) {
        const colorIndex = state.wordColors.size % colorClasses.length;
        state.wordColors.set(foundWord, colorClasses[colorIndex]);
      }
      // Store the cells associated with this word
      state.matchedCells.set(foundWord, selection);
      return true;
    }
    return false;
  }

  function getCellCoordinates(element) {
    if (!element?.dataset?.coords) return null;
    return element.dataset.coords.split("-").map(Number);
  }

  function updateDOM() {
    const gridElement = document.getElementById("grid");
    gridElement.innerHTML = "";
    gridElement.style.gridTemplateColumns = `repeat(${state.size}, 1fr)`;

    state.grid.forEach((row, i) =>
      row.forEach((cell, j) => {
        const cellElement = document.createElement("div");
        cellElement.className = "cell";
        cellElement.textContent = cell;
        cellElement.dataset.coords = `${i}-${j}`;

        const isSelected = state.selectedCells.some(([r, c]) => r === i && c === j);
        
        // Find if this cell belongs to any found word
        let matchedWord = null;
        for (const [word, cells] of state.matchedCells.entries()) {
          if (cells.some(([r, c]) => r === i && c === j)) {
            matchedWord = word;
            break;
          }
        }

        const isSolution = state.showSolution && 
          state.solutions.some((s) => s.cells.some(([r, c]) => r === i && c === j));

        if (isSelected) cellElement.classList.add("selected");
        if (matchedWord) {
          cellElement.classList.add("match");
          const colorClass = state.wordColors.get(matchedWord);
          if (colorClass) {
            cellElement.classList.add(colorClass);
          }
        }
        if (isSolution) {
          const direction = state.solutions.find((s) =>
            s.cells.some(([r, c]) => r === i && c === j)
          )?.direction;
          cellElement.style.backgroundColor = state.directionColors[direction];
        }

        gridElement.appendChild(cellElement);
      })
    );

    document.getElementById("clickCount").textContent = state.clickCount;
    document.getElementById("foundCount").textContent = state.foundWords.length;
    document.getElementById("totalWords").textContent = state.currentWordSet[state.difficulty].length;
    document.getElementById("solutionBtn").textContent = state.showSolution ? "Hide Hints" : "Show Hints";

    const wordList = document.getElementById("wordList");
    wordList.innerHTML = state.currentWordSet[state.difficulty]
      .map(word => {
        const isFound = state.foundWords.includes(word);
        const colorClass = state.wordColors.get(word) || '';
        return `<span class="word ${isFound ? 'found ' + colorClass : ''}">${word}</span>`;
      })
      .join("");
  }

  function handleDragStart(e) {
    const coords = getCellCoordinates(e.target);
    if (!coords) return;

    state.isDragging = true;
    state.selectedCells = [coords];
    state.clickCount++;
    updateDOM();
  }

  function handleDragMove(e) {
    if (!state.isDragging) return;

    const element = document.elementFromPoint(
      e.type.includes("touch") ? e.touches[0].clientX : e.clientX,
      e.type.includes("touch") ? e.touches[0].clientY : e.clientY
    );

    const coords = getCellCoordinates(element);
    if (!coords) return;

    const lastCell = state.selectedCells[state.selectedCells.length - 1];
    if (!lastCell || !isValidNextCell(lastCell, coords)) return;

    if (!state.selectedCells.some(([r, c]) => r === coords[0] && c === coords[1])) {
      state.selectedCells.push(coords);
      updateDOM();
    }
  }

  function handleDragEnd() {
    if (!state.isDragging) return;

    if (checkForWord(state.selectedCells)) {
      updateDOM();
    }

    state.isDragging = false;
    state.selectedCells = [];
    updateDOM();
  }

  document.addEventListener("DOMContentLoaded", () => {
    const gridElement = document.getElementById("grid");

    // Mouse events
    gridElement.addEventListener("mousedown", handleDragStart);
    gridElement.addEventListener("mousemove", handleDragMove);
    document.addEventListener("mouseup", handleDragEnd);

    // Touch events
    gridElement.addEventListener("touchstart", (e) => {
      e.preventDefault();
      handleDragStart(e);
    });

    gridElement.addEventListener("touchmove", (e) => {
      e.preventDefault();
      handleDragMove(e);
    });

    gridElement.addEventListener("touchend", (e) => {
      e.preventDefault();
      handleDragEnd();
    });

    // Controls
    document.getElementById("difficultySelect").addEventListener("change", (e) => {
      state.difficulty = e.target.value;
      generatePuzzleWithCurrentWordSet();
    });

    document.getElementById("newPuzzleBtn").addEventListener("click", generateNewPuzzle);
    document.getElementById("resetBtn").addEventListener("click", resetPuzzle);
    document.getElementById("solutionBtn").addEventListener("click", () => {
      state.showSolution = !state.showSolution;
      updateDOM();
    });

    document.getElementById("clearBtn").addEventListener("click", () => {
      state.selectedCells = [];
      state.isDragging = false;
      updateDOM();
    });

    document.getElementById("themeToggle").addEventListener("click", () => {
      document.body.dataset.theme = document.body.dataset.theme === "dark" ? "" : "dark";
    });

    // Initialize the first puzzle
    generatePuzzleWithCurrentWordSet();
  });
</script>